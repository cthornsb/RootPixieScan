//
// File generated by rootcint at Mon Jul  7 15:18:02 2014

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME srcdIRootDict
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "RootDict.h"

#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"

// Direct notice to TROOT of the dictionary's loading.
namespace {
   static struct DictInit {
      DictInit() {
         ROOT::RegisterModule();
      }
   } __TheDictionaryInitializer;
}

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::BetaDataStructure BetaDataStructure;
      #else
      class BetaDataStructure  {
         public:
         //friend XX;
         double energy; //
         unsigned int multiplicity; //
         bool valid; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::LogicDataStructure LogicDataStructure;
      #else
      class LogicDataStructure  {
         public:
         //friend XX;
         double tdiff; //
         unsigned int location; //
         bool is_start; //
         bool valid; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::RuntimeDataStructure RuntimeDataStructure;
      #else
      class RuntimeDataStructure  {
         public:
         //friend XX;
         double energy; //
         bool valid; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::LiquidDataStructure LiquidDataStructure;
      #else
      class LiquidDataStructure  {
         public:
         //friend XX;
         double TOF; //
         double S; //
         double L; //
         double liquid_tqdc; //
         double start_tqdc; //
         unsigned int location; //
         bool valid; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::VandleDataStructure VandleDataStructure;
      #else
      class VandleDataStructure  {
         public:
         //friend XX;
         double tof; //
         double lqdc; //
         double rqdc; //
         double tsLow; //
         double tsHigh; //
         double lMaxVal; //
         double rMaxVal; //
         double qdc; //
         double energy; //
         unsigned int multiplicity; //
         unsigned int location; //
         bool valid; //
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void BetaDataStructure_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void BetaDataStructure_Dictionary();
   static void *new_BetaDataStructure(void *p = 0);
   static void *newArray_BetaDataStructure(Long_t size, void *p);
   static void delete_BetaDataStructure(void *p);
   static void deleteArray_BetaDataStructure(void *p);
   static void destruct_BetaDataStructure(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BetaDataStructure*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::BetaDataStructure) == sizeof(::ROOT::Shadow::BetaDataStructure));
      ::BetaDataStructure *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BetaDataStructure),0);
      static ::ROOT::TGenericClassInfo 
         instance("BetaDataStructure", "./include/RootDataStructures.h", 4,
                  typeid(::BetaDataStructure), DefineBehavior(ptr, ptr),
                  &BetaDataStructure_ShowMembers, &BetaDataStructure_Dictionary, isa_proxy, 4,
                  sizeof(::BetaDataStructure) );
      instance.SetNew(&new_BetaDataStructure);
      instance.SetNewArray(&newArray_BetaDataStructure);
      instance.SetDelete(&delete_BetaDataStructure);
      instance.SetDeleteArray(&deleteArray_BetaDataStructure);
      instance.SetDestructor(&destruct_BetaDataStructure);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BetaDataStructure*)
   {
      return GenerateInitInstanceLocal((::BetaDataStructure*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BetaDataStructure*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void BetaDataStructure_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::BetaDataStructure*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void LogicDataStructure_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void LogicDataStructure_Dictionary();
   static void *new_LogicDataStructure(void *p = 0);
   static void *newArray_LogicDataStructure(Long_t size, void *p);
   static void delete_LogicDataStructure(void *p);
   static void deleteArray_LogicDataStructure(void *p);
   static void destruct_LogicDataStructure(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::LogicDataStructure*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::LogicDataStructure) == sizeof(::ROOT::Shadow::LogicDataStructure));
      ::LogicDataStructure *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::LogicDataStructure),0);
      static ::ROOT::TGenericClassInfo 
         instance("LogicDataStructure", "./include/RootDataStructures.h", 10,
                  typeid(::LogicDataStructure), DefineBehavior(ptr, ptr),
                  &LogicDataStructure_ShowMembers, &LogicDataStructure_Dictionary, isa_proxy, 4,
                  sizeof(::LogicDataStructure) );
      instance.SetNew(&new_LogicDataStructure);
      instance.SetNewArray(&newArray_LogicDataStructure);
      instance.SetDelete(&delete_LogicDataStructure);
      instance.SetDeleteArray(&deleteArray_LogicDataStructure);
      instance.SetDestructor(&destruct_LogicDataStructure);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::LogicDataStructure*)
   {
      return GenerateInitInstanceLocal((::LogicDataStructure*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::LogicDataStructure*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void LogicDataStructure_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::LogicDataStructure*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void RuntimeDataStructure_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void RuntimeDataStructure_Dictionary();
   static void *new_RuntimeDataStructure(void *p = 0);
   static void *newArray_RuntimeDataStructure(Long_t size, void *p);
   static void delete_RuntimeDataStructure(void *p);
   static void deleteArray_RuntimeDataStructure(void *p);
   static void destruct_RuntimeDataStructure(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RuntimeDataStructure*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::RuntimeDataStructure) == sizeof(::ROOT::Shadow::RuntimeDataStructure));
      ::RuntimeDataStructure *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RuntimeDataStructure),0);
      static ::ROOT::TGenericClassInfo 
         instance("RuntimeDataStructure", "./include/RootDataStructures.h", 16,
                  typeid(::RuntimeDataStructure), DefineBehavior(ptr, ptr),
                  &RuntimeDataStructure_ShowMembers, &RuntimeDataStructure_Dictionary, isa_proxy, 4,
                  sizeof(::RuntimeDataStructure) );
      instance.SetNew(&new_RuntimeDataStructure);
      instance.SetNewArray(&newArray_RuntimeDataStructure);
      instance.SetDelete(&delete_RuntimeDataStructure);
      instance.SetDeleteArray(&deleteArray_RuntimeDataStructure);
      instance.SetDestructor(&destruct_RuntimeDataStructure);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RuntimeDataStructure*)
   {
      return GenerateInitInstanceLocal((::RuntimeDataStructure*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::RuntimeDataStructure*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void RuntimeDataStructure_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::RuntimeDataStructure*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void LiquidDataStructure_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void LiquidDataStructure_Dictionary();
   static void *new_LiquidDataStructure(void *p = 0);
   static void *newArray_LiquidDataStructure(Long_t size, void *p);
   static void delete_LiquidDataStructure(void *p);
   static void deleteArray_LiquidDataStructure(void *p);
   static void destruct_LiquidDataStructure(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::LiquidDataStructure*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::LiquidDataStructure) == sizeof(::ROOT::Shadow::LiquidDataStructure));
      ::LiquidDataStructure *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::LiquidDataStructure),0);
      static ::ROOT::TGenericClassInfo 
         instance("LiquidDataStructure", "./include/RootDataStructures.h", 21,
                  typeid(::LiquidDataStructure), DefineBehavior(ptr, ptr),
                  &LiquidDataStructure_ShowMembers, &LiquidDataStructure_Dictionary, isa_proxy, 4,
                  sizeof(::LiquidDataStructure) );
      instance.SetNew(&new_LiquidDataStructure);
      instance.SetNewArray(&newArray_LiquidDataStructure);
      instance.SetDelete(&delete_LiquidDataStructure);
      instance.SetDeleteArray(&deleteArray_LiquidDataStructure);
      instance.SetDestructor(&destruct_LiquidDataStructure);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::LiquidDataStructure*)
   {
      return GenerateInitInstanceLocal((::LiquidDataStructure*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::LiquidDataStructure*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void LiquidDataStructure_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::LiquidDataStructure*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void VandleDataStructure_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void VandleDataStructure_Dictionary();
   static void *new_VandleDataStructure(void *p = 0);
   static void *newArray_VandleDataStructure(Long_t size, void *p);
   static void delete_VandleDataStructure(void *p);
   static void deleteArray_VandleDataStructure(void *p);
   static void destruct_VandleDataStructure(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::VandleDataStructure*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::VandleDataStructure) == sizeof(::ROOT::Shadow::VandleDataStructure));
      ::VandleDataStructure *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::VandleDataStructure),0);
      static ::ROOT::TGenericClassInfo 
         instance("VandleDataStructure", "./include/RootDataStructures.h", 28,
                  typeid(::VandleDataStructure), DefineBehavior(ptr, ptr),
                  &VandleDataStructure_ShowMembers, &VandleDataStructure_Dictionary, isa_proxy, 4,
                  sizeof(::VandleDataStructure) );
      instance.SetNew(&new_VandleDataStructure);
      instance.SetNewArray(&newArray_VandleDataStructure);
      instance.SetDelete(&delete_VandleDataStructure);
      instance.SetDeleteArray(&deleteArray_VandleDataStructure);
      instance.SetDestructor(&destruct_VandleDataStructure);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::VandleDataStructure*)
   {
      return GenerateInitInstanceLocal((::VandleDataStructure*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::VandleDataStructure*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void VandleDataStructure_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::VandleDataStructure*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
namespace ROOT {
   void BetaDataStructure_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class BetaDataStructure.
      typedef ::ROOT::Shadow::BetaDataStructure ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::BetaDataStructure*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "energy", &sobj->energy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "multiplicity", &sobj->multiplicity);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "valid", &sobj->valid);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_BetaDataStructure(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::BetaDataStructure : new ::BetaDataStructure;
   }
   static void *newArray_BetaDataStructure(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::BetaDataStructure[nElements] : new ::BetaDataStructure[nElements];
   }
   // Wrapper around operator delete
   static void delete_BetaDataStructure(void *p) {
      delete ((::BetaDataStructure*)p);
   }
   static void deleteArray_BetaDataStructure(void *p) {
      delete [] ((::BetaDataStructure*)p);
   }
   static void destruct_BetaDataStructure(void *p) {
      typedef ::BetaDataStructure current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BetaDataStructure

//______________________________________________________________________________
namespace ROOT {
   void LogicDataStructure_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class LogicDataStructure.
      typedef ::ROOT::Shadow::LogicDataStructure ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::LogicDataStructure*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "tdiff", &sobj->tdiff);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "location", &sobj->location);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "is_start", &sobj->is_start);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "valid", &sobj->valid);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_LogicDataStructure(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LogicDataStructure : new ::LogicDataStructure;
   }
   static void *newArray_LogicDataStructure(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LogicDataStructure[nElements] : new ::LogicDataStructure[nElements];
   }
   // Wrapper around operator delete
   static void delete_LogicDataStructure(void *p) {
      delete ((::LogicDataStructure*)p);
   }
   static void deleteArray_LogicDataStructure(void *p) {
      delete [] ((::LogicDataStructure*)p);
   }
   static void destruct_LogicDataStructure(void *p) {
      typedef ::LogicDataStructure current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::LogicDataStructure

//______________________________________________________________________________
namespace ROOT {
   void RuntimeDataStructure_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class RuntimeDataStructure.
      typedef ::ROOT::Shadow::RuntimeDataStructure ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::RuntimeDataStructure*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "energy", &sobj->energy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "valid", &sobj->valid);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RuntimeDataStructure(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RuntimeDataStructure : new ::RuntimeDataStructure;
   }
   static void *newArray_RuntimeDataStructure(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RuntimeDataStructure[nElements] : new ::RuntimeDataStructure[nElements];
   }
   // Wrapper around operator delete
   static void delete_RuntimeDataStructure(void *p) {
      delete ((::RuntimeDataStructure*)p);
   }
   static void deleteArray_RuntimeDataStructure(void *p) {
      delete [] ((::RuntimeDataStructure*)p);
   }
   static void destruct_RuntimeDataStructure(void *p) {
      typedef ::RuntimeDataStructure current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RuntimeDataStructure

//______________________________________________________________________________
namespace ROOT {
   void LiquidDataStructure_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class LiquidDataStructure.
      typedef ::ROOT::Shadow::LiquidDataStructure ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::LiquidDataStructure*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TOF", &sobj->TOF);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "S", &sobj->S);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "L", &sobj->L);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "liquid_tqdc", &sobj->liquid_tqdc);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "start_tqdc", &sobj->start_tqdc);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "location", &sobj->location);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "valid", &sobj->valid);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_LiquidDataStructure(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LiquidDataStructure : new ::LiquidDataStructure;
   }
   static void *newArray_LiquidDataStructure(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LiquidDataStructure[nElements] : new ::LiquidDataStructure[nElements];
   }
   // Wrapper around operator delete
   static void delete_LiquidDataStructure(void *p) {
      delete ((::LiquidDataStructure*)p);
   }
   static void deleteArray_LiquidDataStructure(void *p) {
      delete [] ((::LiquidDataStructure*)p);
   }
   static void destruct_LiquidDataStructure(void *p) {
      typedef ::LiquidDataStructure current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::LiquidDataStructure

//______________________________________________________________________________
namespace ROOT {
   void VandleDataStructure_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class VandleDataStructure.
      typedef ::ROOT::Shadow::VandleDataStructure ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::VandleDataStructure*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "tof", &sobj->tof);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "lqdc", &sobj->lqdc);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "rqdc", &sobj->rqdc);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "tsLow", &sobj->tsLow);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "tsHigh", &sobj->tsHigh);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "lMaxVal", &sobj->lMaxVal);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "rMaxVal", &sobj->rMaxVal);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "qdc", &sobj->qdc);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "energy", &sobj->energy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "multiplicity", &sobj->multiplicity);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "location", &sobj->location);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "valid", &sobj->valid);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_VandleDataStructure(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::VandleDataStructure : new ::VandleDataStructure;
   }
   static void *newArray_VandleDataStructure(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::VandleDataStructure[nElements] : new ::VandleDataStructure[nElements];
   }
   // Wrapper around operator delete
   static void delete_VandleDataStructure(void *p) {
      delete ((::VandleDataStructure*)p);
   }
   static void deleteArray_VandleDataStructure(void *p) {
      delete [] ((::VandleDataStructure*)p);
   }
   static void destruct_VandleDataStructure(void *p) {
      typedef ::VandleDataStructure current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::VandleDataStructure

/********************************************************
* src/RootDict.cpp
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableRootDict();

extern "C" void G__set_cpp_environmentRootDict() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("include/RootDataStructures.h");
  G__cpp_reset_tagtableRootDict();
}
#include <new>
extern "C" int G__cpp_dllrevRootDict() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* BetaDataStructure */
// automatic default constructor
static int G__RootDict_168_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   BetaDataStructure *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new BetaDataStructure[n];
     } else {
       p = new((void*) gvp) BetaDataStructure[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new BetaDataStructure;
     } else {
       p = new((void*) gvp) BetaDataStructure;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_BetaDataStructure));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__RootDict_168_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   BetaDataStructure* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new BetaDataStructure(*(BetaDataStructure*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_BetaDataStructure));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef BetaDataStructure G__TBetaDataStructure;
static int G__RootDict_168_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (BetaDataStructure*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((BetaDataStructure*) (soff+(sizeof(BetaDataStructure)*i)))->~G__TBetaDataStructure();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (BetaDataStructure*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((BetaDataStructure*) (soff))->~G__TBetaDataStructure();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__RootDict_168_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   BetaDataStructure* dest = (BetaDataStructure*) G__getstructoffset();
   *dest = *(BetaDataStructure*) libp->para[0].ref;
   const BetaDataStructure& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* LogicDataStructure */
// automatic default constructor
static int G__RootDict_169_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LogicDataStructure *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LogicDataStructure[n];
     } else {
       p = new((void*) gvp) LogicDataStructure[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LogicDataStructure;
     } else {
       p = new((void*) gvp) LogicDataStructure;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_LogicDataStructure));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__RootDict_169_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   LogicDataStructure* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new LogicDataStructure(*(LogicDataStructure*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_LogicDataStructure));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef LogicDataStructure G__TLogicDataStructure;
static int G__RootDict_169_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (LogicDataStructure*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((LogicDataStructure*) (soff+(sizeof(LogicDataStructure)*i)))->~G__TLogicDataStructure();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (LogicDataStructure*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((LogicDataStructure*) (soff))->~G__TLogicDataStructure();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__RootDict_169_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LogicDataStructure* dest = (LogicDataStructure*) G__getstructoffset();
   *dest = *(LogicDataStructure*) libp->para[0].ref;
   const LogicDataStructure& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* RuntimeDataStructure */
// automatic default constructor
static int G__RootDict_170_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RuntimeDataStructure *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RuntimeDataStructure[n];
     } else {
       p = new((void*) gvp) RuntimeDataStructure[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RuntimeDataStructure;
     } else {
       p = new((void*) gvp) RuntimeDataStructure;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_RuntimeDataStructure));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__RootDict_170_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   RuntimeDataStructure* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new RuntimeDataStructure(*(RuntimeDataStructure*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_RuntimeDataStructure));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef RuntimeDataStructure G__TRuntimeDataStructure;
static int G__RootDict_170_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (RuntimeDataStructure*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((RuntimeDataStructure*) (soff+(sizeof(RuntimeDataStructure)*i)))->~G__TRuntimeDataStructure();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (RuntimeDataStructure*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((RuntimeDataStructure*) (soff))->~G__TRuntimeDataStructure();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__RootDict_170_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RuntimeDataStructure* dest = (RuntimeDataStructure*) G__getstructoffset();
   *dest = *(RuntimeDataStructure*) libp->para[0].ref;
   const RuntimeDataStructure& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* LiquidDataStructure */
// automatic default constructor
static int G__RootDict_171_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LiquidDataStructure *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LiquidDataStructure[n];
     } else {
       p = new((void*) gvp) LiquidDataStructure[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LiquidDataStructure;
     } else {
       p = new((void*) gvp) LiquidDataStructure;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_LiquidDataStructure));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__RootDict_171_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   LiquidDataStructure* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new LiquidDataStructure(*(LiquidDataStructure*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_LiquidDataStructure));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef LiquidDataStructure G__TLiquidDataStructure;
static int G__RootDict_171_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (LiquidDataStructure*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((LiquidDataStructure*) (soff+(sizeof(LiquidDataStructure)*i)))->~G__TLiquidDataStructure();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (LiquidDataStructure*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((LiquidDataStructure*) (soff))->~G__TLiquidDataStructure();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__RootDict_171_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LiquidDataStructure* dest = (LiquidDataStructure*) G__getstructoffset();
   *dest = *(LiquidDataStructure*) libp->para[0].ref;
   const LiquidDataStructure& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* VandleDataStructure */
// automatic default constructor
static int G__RootDict_172_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   VandleDataStructure *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new VandleDataStructure[n];
     } else {
       p = new((void*) gvp) VandleDataStructure[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new VandleDataStructure;
     } else {
       p = new((void*) gvp) VandleDataStructure;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_VandleDataStructure));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__RootDict_172_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   VandleDataStructure* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new VandleDataStructure(*(VandleDataStructure*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_VandleDataStructure));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef VandleDataStructure G__TVandleDataStructure;
static int G__RootDict_172_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (VandleDataStructure*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((VandleDataStructure*) (soff+(sizeof(VandleDataStructure)*i)))->~G__TVandleDataStructure();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (VandleDataStructure*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((VandleDataStructure*) (soff))->~G__TVandleDataStructure();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__RootDict_172_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   VandleDataStructure* dest = (VandleDataStructure*) G__getstructoffset();
   *dest = *(VandleDataStructure*) libp->para[0].ref;
   const VandleDataStructure& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* BetaDataStructure */

/* LogicDataStructure */

/* RuntimeDataStructure */

/* LiquidDataStructure */

/* VandleDataStructure */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncRootDict {
 public:
  G__Sizep2memfuncRootDict(): p(&G__Sizep2memfuncRootDict::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncRootDict::*p)();
};

size_t G__get_sizep2memfuncRootDict()
{
  G__Sizep2memfuncRootDict a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceRootDict() {

   /* Setting up class inheritance */
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableRootDict() {

   /* Setting up typedef entry */
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__RootDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__RootDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__RootDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__RootDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__RootDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__RootDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__RootDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__RootDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__RootDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__RootDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* BetaDataStructure */
static void G__setup_memvarBetaDataStructure(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__RootDictLN_BetaDataStructure));
   { BetaDataStructure *p; p=(BetaDataStructure*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->energy)-(long)(p)),100,0,0,-1,-1,-1,1,"energy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->multiplicity)-(long)(p)),104,0,0,-1,-1,-1,1,"multiplicity=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->valid)-(long)(p)),103,0,0,-1,-1,-1,1,"valid=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* LogicDataStructure */
static void G__setup_memvarLogicDataStructure(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__RootDictLN_LogicDataStructure));
   { LogicDataStructure *p; p=(LogicDataStructure*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->tdiff)-(long)(p)),100,0,0,-1,-1,-1,1,"tdiff=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->location)-(long)(p)),104,0,0,-1,-1,-1,1,"location=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->is_start)-(long)(p)),103,0,0,-1,-1,-1,1,"is_start=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->valid)-(long)(p)),103,0,0,-1,-1,-1,1,"valid=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* RuntimeDataStructure */
static void G__setup_memvarRuntimeDataStructure(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__RootDictLN_RuntimeDataStructure));
   { RuntimeDataStructure *p; p=(RuntimeDataStructure*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->energy)-(long)(p)),100,0,0,-1,-1,-1,1,"energy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->valid)-(long)(p)),103,0,0,-1,-1,-1,1,"valid=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* LiquidDataStructure */
static void G__setup_memvarLiquidDataStructure(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__RootDictLN_LiquidDataStructure));
   { LiquidDataStructure *p; p=(LiquidDataStructure*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->TOF)-(long)(p)),100,0,0,-1,-1,-1,1,"TOF=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->S)-(long)(p)),100,0,0,-1,-1,-1,1,"S=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->L)-(long)(p)),100,0,0,-1,-1,-1,1,"L=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->liquid_tqdc)-(long)(p)),100,0,0,-1,-1,-1,1,"liquid_tqdc=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->start_tqdc)-(long)(p)),100,0,0,-1,-1,-1,1,"start_tqdc=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->location)-(long)(p)),104,0,0,-1,-1,-1,1,"location=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->valid)-(long)(p)),103,0,0,-1,-1,-1,1,"valid=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* VandleDataStructure */
static void G__setup_memvarVandleDataStructure(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__RootDictLN_VandleDataStructure));
   { VandleDataStructure *p; p=(VandleDataStructure*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->tof)-(long)(p)),100,0,0,-1,-1,-1,1,"tof=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->lqdc)-(long)(p)),100,0,0,-1,-1,-1,1,"lqdc=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->rqdc)-(long)(p)),100,0,0,-1,-1,-1,1,"rqdc=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->tsLow)-(long)(p)),100,0,0,-1,-1,-1,1,"tsLow=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->tsHigh)-(long)(p)),100,0,0,-1,-1,-1,1,"tsHigh=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->lMaxVal)-(long)(p)),100,0,0,-1,-1,-1,1,"lMaxVal=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->rMaxVal)-(long)(p)),100,0,0,-1,-1,-1,1,"rMaxVal=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->qdc)-(long)(p)),100,0,0,-1,-1,-1,1,"qdc=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->energy)-(long)(p)),100,0,0,-1,-1,-1,1,"energy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->multiplicity)-(long)(p)),104,0,0,-1,-1,-1,1,"multiplicity=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->location)-(long)(p)),104,0,0,-1,-1,-1,1,"location=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->valid)-(long)(p)),103,0,0,-1,-1,-1,1,"valid=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarRootDict() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncBetaDataStructure(void) {
   /* BetaDataStructure */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__RootDictLN_BetaDataStructure));
   // automatic default constructor
   G__memfunc_setup("BetaDataStructure", 1735, G__RootDict_168_0_1, (int) ('i'), G__get_linked_tagnum(&G__RootDictLN_BetaDataStructure), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("BetaDataStructure", 1735, G__RootDict_168_0_2, (int) ('i'), G__get_linked_tagnum(&G__RootDictLN_BetaDataStructure), -1, 0, 1, 1, 1, 0, "u 'BetaDataStructure' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BetaDataStructure", 1861, G__RootDict_168_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__RootDict_168_0_4, (int) ('u'), G__get_linked_tagnum(&G__RootDictLN_BetaDataStructure), -1, 1, 1, 1, 1, 0, "u 'BetaDataStructure' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncLogicDataStructure(void) {
   /* LogicDataStructure */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__RootDictLN_LogicDataStructure));
   // automatic default constructor
   G__memfunc_setup("LogicDataStructure", 1849, G__RootDict_169_0_1, (int) ('i'), G__get_linked_tagnum(&G__RootDictLN_LogicDataStructure), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("LogicDataStructure", 1849, G__RootDict_169_0_2, (int) ('i'), G__get_linked_tagnum(&G__RootDictLN_LogicDataStructure), -1, 0, 1, 1, 1, 0, "u 'LogicDataStructure' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~LogicDataStructure", 1975, G__RootDict_169_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__RootDict_169_0_4, (int) ('u'), G__get_linked_tagnum(&G__RootDictLN_LogicDataStructure), -1, 1, 1, 1, 1, 0, "u 'LogicDataStructure' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncRuntimeDataStructure(void) {
   /* RuntimeDataStructure */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__RootDictLN_RuntimeDataStructure));
   // automatic default constructor
   G__memfunc_setup("RuntimeDataStructure", 2095, G__RootDict_170_0_1, (int) ('i'), G__get_linked_tagnum(&G__RootDictLN_RuntimeDataStructure), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RuntimeDataStructure", 2095, G__RootDict_170_0_2, (int) ('i'), G__get_linked_tagnum(&G__RootDictLN_RuntimeDataStructure), -1, 0, 1, 1, 1, 0, "u 'RuntimeDataStructure' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RuntimeDataStructure", 2221, G__RootDict_170_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__RootDict_170_0_4, (int) ('u'), G__get_linked_tagnum(&G__RootDictLN_RuntimeDataStructure), -1, 1, 1, 1, 1, 0, "u 'RuntimeDataStructure' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncLiquidDataStructure(void) {
   /* LiquidDataStructure */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__RootDictLN_LiquidDataStructure));
   // automatic default constructor
   G__memfunc_setup("LiquidDataStructure", 1971, G__RootDict_171_0_1, (int) ('i'), G__get_linked_tagnum(&G__RootDictLN_LiquidDataStructure), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("LiquidDataStructure", 1971, G__RootDict_171_0_2, (int) ('i'), G__get_linked_tagnum(&G__RootDictLN_LiquidDataStructure), -1, 0, 1, 1, 1, 0, "u 'LiquidDataStructure' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~LiquidDataStructure", 2097, G__RootDict_171_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__RootDict_171_0_4, (int) ('u'), G__get_linked_tagnum(&G__RootDictLN_LiquidDataStructure), -1, 1, 1, 1, 1, 0, "u 'LiquidDataStructure' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncVandleDataStructure(void) {
   /* VandleDataStructure */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__RootDictLN_VandleDataStructure));
   // automatic default constructor
   G__memfunc_setup("VandleDataStructure", 1957, G__RootDict_172_0_1, (int) ('i'), G__get_linked_tagnum(&G__RootDictLN_VandleDataStructure), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("VandleDataStructure", 1957, G__RootDict_172_0_2, (int) ('i'), G__get_linked_tagnum(&G__RootDictLN_VandleDataStructure), -1, 0, 1, 1, 1, 0, "u 'VandleDataStructure' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VandleDataStructure", 2083, G__RootDict_172_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__RootDict_172_0_4, (int) ('u'), G__get_linked_tagnum(&G__RootDictLN_VandleDataStructure), -1, 1, 1, 1, 1, 0, "u 'VandleDataStructure' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncRootDict() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"ROOTDATASTRUCTURE_H=0",1,(char*)NULL);

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalRootDict() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcRootDict() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__RootDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__RootDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__RootDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__RootDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__RootDictLN_BetaDataStructure = { "BetaDataStructure" , 115 , -1 };
G__linked_taginfo G__RootDictLN_LogicDataStructure = { "LogicDataStructure" , 115 , -1 };
G__linked_taginfo G__RootDictLN_RuntimeDataStructure = { "RuntimeDataStructure" , 115 , -1 };
G__linked_taginfo G__RootDictLN_LiquidDataStructure = { "LiquidDataStructure" , 115 , -1 };
G__linked_taginfo G__RootDictLN_VandleDataStructure = { "VandleDataStructure" , 115 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableRootDict() {
  G__RootDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__RootDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__RootDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__RootDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__RootDictLN_BetaDataStructure.tagnum = -1 ;
  G__RootDictLN_LogicDataStructure.tagnum = -1 ;
  G__RootDictLN_RuntimeDataStructure.tagnum = -1 ;
  G__RootDictLN_LiquidDataStructure.tagnum = -1 ;
  G__RootDictLN_VandleDataStructure.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableRootDict() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__RootDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__RootDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__RootDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__RootDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__RootDictLN_BetaDataStructure),sizeof(BetaDataStructure),-1,262144,(char*)NULL,G__setup_memvarBetaDataStructure,G__setup_memfuncBetaDataStructure);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__RootDictLN_LogicDataStructure),sizeof(LogicDataStructure),-1,262144,(char*)NULL,G__setup_memvarLogicDataStructure,G__setup_memfuncLogicDataStructure);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__RootDictLN_RuntimeDataStructure),sizeof(RuntimeDataStructure),-1,262144,(char*)NULL,G__setup_memvarRuntimeDataStructure,G__setup_memfuncRuntimeDataStructure);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__RootDictLN_LiquidDataStructure),sizeof(LiquidDataStructure),-1,262144,(char*)NULL,G__setup_memvarLiquidDataStructure,G__setup_memfuncLiquidDataStructure);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__RootDictLN_VandleDataStructure),sizeof(VandleDataStructure),-1,262144,(char*)NULL,G__setup_memvarVandleDataStructure,G__setup_memfuncVandleDataStructure);
}
extern "C" void G__cpp_setupRootDict(void) {
  G__check_setup_version(30051515,"G__cpp_setupRootDict()");
  G__set_cpp_environmentRootDict();
  G__cpp_setup_tagtableRootDict();

  G__cpp_setup_inheritanceRootDict();

  G__cpp_setup_typetableRootDict();

  G__cpp_setup_memvarRootDict();

  G__cpp_setup_memfuncRootDict();
  G__cpp_setup_globalRootDict();
  G__cpp_setup_funcRootDict();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncRootDict();
  return;
}
class G__cpp_setup_initRootDict {
  public:
    G__cpp_setup_initRootDict() { G__add_setup_func("RootDict",(G__incsetup)(&G__cpp_setupRootDict)); G__call_setup_funcs(); }
   ~G__cpp_setup_initRootDict() { G__remove_setup_func("RootDict"); }
};
G__cpp_setup_initRootDict G__cpp_setup_initializerRootDict;

